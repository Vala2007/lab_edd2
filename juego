import customtkinter as ctk
from tkinter import messagebox
import random


class Nodo:
    def __init__(self, nombre, retos):
        self.nombre = nombre
        self.retos = retos
        self.izquierda = None
        self.derecha = None

    def obtener_reto(self):
        return random.choice(self.retos)


class JuegoCiberseguridadCTK:
    def __init__(self, root):
        self.root = root
        self.root.title("Aventura Cibern√©tica üß†")
        self.root.geometry("1250x600")

        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("green")

        # Construcci√≥n del √°rbol
        self.raiz = self.construir_arbol()
        self.objetivo = "Nodo Central Seguro"
        self.actual = self.raiz
        self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()

        # Seguimiento de progreso (Ajna)
        self.nodos_visitados = []
        self.nodos_correctos = set()
        self.nodos_pendientes = set()
        self.nodos_usadas_en_pistas = set()
        self.contador_respuestas = 0
        self.mapa_visible = False
        self.botones_mapa = {}

        # Interfaz
        self.main_frame = ctk.CTkFrame(root)
        self.main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        self.frame_juego = ctk.CTkFrame(self.main_frame)
        self.frame_juego.pack(side="left", fill="both", expand=True, padx=10)

        self.titulo = ctk.CTkLabel(self.frame_juego, text="üåê Aventura Cibern√©tica üåê",
                                   font=("Arial Rounded MT Bold", 24))
        self.titulo.pack(pady=10)

        self.texto_nodo = ctk.CTkLabel(self.frame_juego, text="", font=("Arial", 18, "bold"), wraplength=600)
        self.texto_nodo.pack(pady=10)

        self.texto_reto = ctk.CTkLabel(self.frame_juego, text="", font=("Arial", 15), wraplength=600)
        self.texto_reto.pack(pady=10)

        self.entrada = ctk.CTkEntry(self.frame_juego, width=300, font=("Arial", 14))
        self.entrada.pack(pady=5)
        self.entrada.bind("<Return>", lambda event: self.validar_respuesta())

        self.boton_responder = ctk.CTkButton(self.frame_juego, text="Responder",
                                             command=self.validar_respuesta, width=120, height=35)
        self.boton_responder.pack(pady=5)

        # Botones de movimiento
        self.frame_botones = ctk.CTkFrame(self.frame_juego)
        self.frame_botones.pack(pady=15)

        self.boton_izquierda = ctk.CTkButton(self.frame_botones, text="‚Üê Izquierda", width=120,
                                             command=lambda: self.mover("izquierda"), state="disabled")
        self.boton_izquierda.grid(row=0, column=0, padx=10)

        self.boton_derecha = ctk.CTkButton(self.frame_botones, text="Derecha ‚Üí", width=120,
                                           command=lambda: self.mover("derecha"), state="disabled")
        self.boton_derecha.grid(row=0, column=1, padx=10)

        self.boton_salir = ctk.CTkButton(self.frame_juego, text="Salir", fg_color="#ff4c4c",
                                         hover_color="#d12d2d", command=root.quit, width=100, height=30)
        self.boton_salir.pack(pady=10)

        # Panel derecho
        self.frame_info = ctk.CTkFrame(self.main_frame)
        self.frame_info.pack(side="right", fill="both", padx=10, pady=10)

        # Lista de nodos visitados 
        self.titulo_visitados = ctk.CTkLabel(self.frame_info, text="üó∫Ô∏è Nodos visitados",
                                            font=("Arial Rounded MT Bold", 16))
        self.titulo_visitados.pack(pady=10)

        self.frame_nodos = ctk.CTkScrollableFrame(self.frame_info, width=250, height=250)
        self.frame_nodos.pack(pady=5)

        # Pistas (Ajna)
        self.label_pista = ctk.CTkLabel(self.frame_info, text="A√∫n no hay pistas disponibles.",
                                        font=("Arial", 13), wraplength=250, justify="left")
        self.label_pista.pack(pady=10)

        # Mapa (inicialmente oculto) (Vala)
        self.frame_mapa = ctk.CTkFrame(self.frame_info)
        self.mapa_frame = ctk.CTkFrame(self.frame_mapa, width=600, height=400)
        self.mapa_frame.pack_propagate(False)
        self.mapa_frame.pack(fill="both", expand=True, padx=10, pady=10)
        self.nodos_visitados.append(self.actual.nombre)
        self.actualizar_lista_nodos()
        self.mostrar_nodo()


    # Construcci√≥n del √°rbol (Jose)
    def construir_arbol(self):
        self.nodo_central = Nodo("Nodo Central Seguro", [
            ("Has restaurado la red. ¬°Felicitaciones, has ganado!", "")
        ])

        ids = Nodo("Sistema IDS", [
            ("¬øQu√© hace un sistema IDS?\n"
            "a) Detecta intrusiones\n"
            "b) Administra contrase√±as\n"
            "c) Realiza copias de seguridad", "a"),
            ("¬øCu√°l es una limitaci√≥n com√∫n de los IDS?\n"
            "a) No requieren configuraci√≥n\n"
            "b) No detectan ataques nuevos o desconocidos\n"
            "c) No consumen memoria", "b"),
            ("¬øQu√© tipo de IDS analiza el tr√°fico en tiempo real?\n"
            "a) IDS basado en host\n"
            "b) IDS basado en red\n"
            "c) IDS h√≠brido", "b")
        ])

        proxy = Nodo("Proxy Seguro", [
            ("¬øPara qu√© sirve un proxy?\n"
            "a) Cifrar discos duros\n"
            "b) Analizar paquetes f√≠sicos\n"
            "c) Ocultar IPs y filtrar tr√°fico", "c"),
            ("¬øQu√© tipo de proxy almacena temporalmente contenido web?\n"
            "a) Proxy inverso\n"
            "b) Proxy cach√©\n"
            "c) Proxy abierto", "b"),
            ("¬øQu√© ventaja tiene usar un proxy corporativo?\n"
            "a) Controlar el acceso a sitios web\n"
            "b) Aumentar el tama√±o del disco duro\n"
            "c) Reducir el n√∫mero de empleados", "a")
        ])

        servidor_web = Nodo("Servidor Web", [
            ("¬øQu√© ataque explota formularios sin validaci√≥n?\n"
            "a) DDoS\n"
            "b) Phishing\n"
            "c) Inyecci√≥n SQL", "c"),
            ("¬øQu√© medida reduce el riesgo de ataques XSS?\n"
            "a) Usar contrase√±as largas\n"
            "b) Escapar o validar entradas del usuario\n"
            "c) Reiniciar el servidor", "b"),
            ("¬øQu√© protocolo usa HTTPS?\n"
            "a) SSH\n"
            "b) TLS/SSL\n"
            "c) FTP", "b")
        ])

        base_datos = Nodo("Base de Datos", [
            ("¬øQu√© protege mejor una base de datos?\n"
            "a) Cifrar datos\n"
            "b) Dejar acceso libre\n"
            "c) Contrase√±as simples", "a"),
            ("¬øQu√© pr√°ctica es peligrosa al gestionar bases de datos?\n"
            "a) Aplicar backups autom√°ticos\n"
            "b) Usar usuarios administrativos para todo\n"
            "c) Tener un firewall activo", "b"),
            ("¬øQu√© comando en SQL puede eliminar informaci√≥n permanentemente?\n"
            "a) DROP\n"
            "b) SELECT\n"
            "c) INSERT", "a")
        ])

        firewall = Nodo("Firewall Perimetral", [
            ("¬øCu√°l es la funci√≥n principal de un firewall?\n"
            "a) Guardar archivos en la nube\n"
            "b) Detectar virus autom√°ticamente\n"
            "c) Filtrar tr√°fico entre redes", "c"),
            ("¬øQu√© tipo de firewall examina el contenido de los paquetes?\n"
            "a) De circuito\n"
            "b) De inspecci√≥n profunda (DPI)\n"
            "c) De hardware", "b"),
            ("¬øQu√© puede causar una mala configuraci√≥n del firewall?\n"
            "a) Bloqueo de servicios leg√≠timos\n"
            "b) Mayor velocidad de conexi√≥n\n"
            "c) Autenticaci√≥n autom√°tica", "a")
        ])

        correo = Nodo("Servidor de Correo", [
            ("Identifica el phishing:\n"
            "a) Correo con enlace sospechoso\n"
            "b) Correo sin adjuntos\n"
            "c) Correo interno leg√≠timo", "a"),
            ("¬øQu√© protocolo se usa para enviar correos?\n"
            "a) IMAP\n"
            "b) POP3\n"
            "c) SMTP", "c"),
            ("¬øQu√© medida ayuda a evitar correos falsificados?\n"
            "a) Implementar SPF o DKIM\n"
            "b) Desactivar el antivirus\n"
            "c) Usar contrase√±as cortas", "a")
        ])

        raiz = Nodo("Servidor Principal", [
            ("Detecta la vulnerabilidad m√°s grave:\n"
            "a) Sistema actualizado\n"
            "b) Contrase√±a d√©bil\n"
            "c) Antivirus activo", "b"),
            ("¬øQu√© acci√≥n mejora la seguridad de un servidor?\n"
            "a) Usar la misma clave para todo\n"
            "b) Apagar el firewall\n"
            "c) Aplicar parches y actualizaciones", "c"),
            ("¬øQu√© herramienta se usa para monitorear el rendimiento del servidor?\n"
            "a) Wireshark\n"
            "b) Task Manager o top\n"
            "c) Paint", "b")
        ])

        logs_servidor = Nodo("Logs de Servidor", [
            ("Si ves muchos intentos de contrase√±a fallidos en los registros, ¬øqu√© puede estar pasando?\n"
            "a) Ataque de fuerza bruta\n"
            "b) Usuario sin permisos\n"
            "c) Error del teclado", "a"),
            ("¬øPor qu√© es √∫til centralizar los logs?\n"
            "a) Ocupa menos espacio\n"
            "b) Facilita la detecci√≥n de anomal√≠as\n"
            "c) Evita el uso de antivirus", "b"),
            ("¬øQu√© formato se usa com√∫nmente para logs?\n"
            "a) JSON o texto plano\n"
            "b) PDF\n"
            "c) JPEG", "a")
        ])

        gestion_parches = Nodo("Gesti√≥n de Parches", [
            ("Cuando un programa tiene un error de seguridad, el fabricante env√≠a una 'actualizaci√≥n'. ¬øQu√© debes hacer?\n"
            "a) Esperar un a√±o\n"
            "b) Instalar la actualizaci√≥n de inmediato\n"
            "c) Ignorarla", "b"),
            ("¬øQu√© pasa si no aplicas los parches de seguridad?\n"
            "a) El sistema puede ser vulnerable a ataques conocidos\n"
            "b) Mejora el rendimiento\n"
            "c) Se actualiza solo", "a"),
            ("¬øQu√© herramienta automatiza la instalaci√≥n de parches?\n"
            "a) Windows Update o apt\n"
            "b) Paint\n"
            "c) Task Manager", "a")
        ])



        configuracion = random.choice([1, 2, 3])

        if configuracion == 1:
            raiz.izquierda = firewall
            raiz.derecha = correo
            firewall.izquierda = ids
            firewall.derecha = proxy
            proxy.derecha = self.nodo_central
            correo.izquierda = servidor_web
            correo.derecha = base_datos
            ids.izquierda = logs_servidor
            ids.derecha = gestion_parches

        elif configuracion == 2:
            raiz.izquierda = proxy
            raiz.derecha = firewall
            proxy.izquierda = ids
            proxy.derecha = servidor_web
            servidor_web.derecha = self.nodo_central
            firewall.izquierda = base_datos
            firewall.derecha = correo
            ids.izquierda = logs_servidor
            ids.derecha = gestion_parches

        else:  
            raiz.izquierda = correo
            raiz.derecha = base_datos
            correo.izquierda = firewall
            correo.derecha = ids
            ids.izquierda = gestion_parches
            ids.derecha = proxy
            base_datos.derecha = servidor_web
            proxy.derecha = self.nodo_central  
            firewall.izquierda = logs_servidor

        # Asegurar que el nodo central no tenga hijos
        self.nodo_central.izquierda = None
        self.nodo_central.derecha = None

        print(f"Configuraci√≥n seleccionada: {configuracion}")
        return raiz



    # Mostrar nodo actual
    def mostrar_nodo(self):
        self.texto_nodo.configure(text=f"üîπ Est√°s en: {self.actual.nombre}")
        self.texto_reto.configure(text=self.pregunta_actual)
        self.entrada.delete(0, 'end')
        self.entrada.focus()
        self.boton_izquierda.configure(state="disabled")
        self.boton_derecha.configure(state="disabled")

        if self.actual.nombre not in self.nodos_visitados:
            self.nodos_visitados.append(self.actual.nombre)
            self.actualizar_lista_nodos()

        if self.mapa_visible:
            self.actualizar_mapa()


    # Lista de nodos visitados (Ajna)
    def actualizar_lista_nodos(self):
        for widget in self.frame_nodos.winfo_children():
            widget.destroy()

        for nodo in self.nodos_visitados:
            boton = ctk.CTkButton(self.frame_nodos, text=f"‚úÖ {nodo}", width=220, height=28,
                                  command=lambda n=nodo: self.ir_a_nodo(n))
            boton.pack(pady=3)


    def ir_a_nodo(self, nombre_nodo):
        nodo = self.buscar_nodo_por_nombre(self.raiz, nombre_nodo)
        if nodo:
            self.actual = nodo
            self.pregunta_actual, self.respuesta_correcta = nodo.obtener_reto()
            messagebox.showinfo("üß≠ Navegaci√≥n", f"Has vuelto al nodo: {nombre_nodo}")
            self.mostrar_nodo()
        else:
            messagebox.showwarning("Error", "No se pudo encontrar el nodo en el √°rbol.")


    def buscar_nodo_por_nombre(self, raiz, nombre):
        if raiz is None:
            return None
        if raiz.nombre == nombre:
            return raiz
        return self.buscar_nodo_por_nombre(raiz.izquierda, nombre) or \
               self.buscar_nodo_por_nombre(raiz.derecha, nombre)


    # Validaci√≥n de respuesta (Vala)
    def validar_respuesta(self):
        respuesta = self.entrada.get().strip().lower()

        if self.actual.nombre == self.objetivo:
            messagebox.showinfo("Victoria", self.pregunta_actual)
            self.root.quit()
            return

        if respuesta != self.respuesta_correcta:
            messagebox.showwarning("Incorrecto", "‚ùå Respuesta incorrecta")
            self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()
            self.mostrar_nodo()
        else:
            messagebox.showinfo("Correcto", "‚úÖ Respuesta correcta. Puedes avanzar.")
            self.boton_izquierda.configure(state="normal")
            self.boton_derecha.configure(state="normal")

            if self.actual.nombre not in self.nodos_correctos:
                self.nodos_correctos.add(self.actual.nombre)
                self.contador_respuestas += 1

            if self.contador_respuestas % 2 == 0:
                self.mostrar_pista()


    # Movimiento entre nodos 
    def mover(self, direccion):
        if direccion == "izquierda" and self.actual.izquierda:
            self.actual = self.actual.izquierda
        elif direccion == "derecha" and self.actual.derecha:
            self.actual = self.actual.derecha
        else:
            messagebox.showinfo("Movimiento inv√°lido", "No hay nodo en esa direcci√≥n.")
            return

        self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()
        self.mostrar_nodo()


    # Pistas y mapa (Ajna)
    def mostrar_pista(self):
        if not self.mapa_visible:
            self.frame_mapa.pack(fill="both", expand=True, padx=10, pady=10)
            self.mapa_visible = True
            self.actualizar_mapa()
            self.root.after(1800, self.ocultar_mapa)

        camino_actual = self.encontrar_camino(self.raiz, self.actual.nombre)
        camino_objetivo = self.encontrar_camino(self.raiz, self.objetivo)

        if not camino_actual or not camino_objetivo:
            self.label_pista.configure(text="‚ùì No se pudo calcular la pista.")
            return

        direcciones_actual, nombres_actual = camino_actual
        direcciones_objetivo, nombres_objetivo = camino_objetivo

        # Si ya estamos en el nodo final
        if self.actual.nombre == self.objetivo:
            self.label_pista.configure(text="üèÅ ¬°Ya est√°s en el Nodo Central Seguro!")
            return

        # Caso 1: si el nodo actual aparece dentro del camino del objetivo
        if self.actual.nombre in nombres_objetivo:
            idx = nombres_objetivo.index(self.actual.nombre)
            if idx < len(direcciones_objetivo):
                siguiente_dir = direcciones_objetivo[idx]
                siguiente_nodo = nombres_objetivo[idx + 1]
                self.label_pista.configure(
                    text=f"üí° Desde aqu√≠, el objetivo est√° hacia la {siguiente_dir}"
                )
            else:
                self.label_pista.configure(text="Ya casi llegas al nodo final.")
        else:
            # Caso 2: si el nodo actual no est√° en el camino correcto
            self.label_pista.configure(
                text="Est√°s en una rama diferente"
            )

    #(Vala)
    def ocultar_mapa(self): 
        if self.mapa_visible:
            self.frame_mapa.pack_forget()
            self.mapa_visible = False
            self.label_pista.configure(text="üïµÔ∏è‚Äç‚ôÇÔ∏è El mapa se ha ocultado. ¬°Sigue explorando!")


    def actualizar_mapa(self):
        for widget in self.mapa_frame.winfo_children():
            widget.destroy()
        
        self.dibujar_arbol_recursivo(self.raiz, 0, 0, 8)  #8 es el ancho total inicial

    def dibujar_arbol_recursivo(self, nodo, nivel, col_izquierda, ancho_total):
        if not nodo:
            return
        
        columna = col_izquierda + ancho_total // 2
        
        self.crear_label(nodo, nivel, columna)
        
        if nodo.izquierda or nodo.derecha:
            nuevo_ancho = ancho_total // 2
            if nodo.izquierda:
                self.dibujar_arbol_recursivo(nodo.izquierda, nivel + 1, col_izquierda, nuevo_ancho)
            if nodo.derecha:
                self.dibujar_arbol_recursivo(nodo.derecha, nivel + 1, col_izquierda + nuevo_ancho, nuevo_ancho)

    def crear_label(self, nodo, fila, col):
        if not nodo:
            return
        color = "#2ecc71" if nodo.nombre in self.nodos_visitados else "#555555"
        lbl = ctk.CTkLabel(
            self.mapa_frame,
            text=nodo.nombre,
            font=("Arial", 9, "bold"),
            fg_color=color,
            corner_radius=10,
            width=35,       
            height=20,       
            wraplength=90,   
            justify="center" 
        )
        lbl.grid(row=fila, column=col, padx=4, pady=4)


    def encontrar_camino(self, raiz, destino, camino=None, nombres=None):
        if raiz is None:
            return None
        if camino is None:
            camino = []
        if nombres is None:
            nombres = [raiz.nombre]
        if raiz.nombre == destino:
            return camino, nombres
        if raiz.izquierda:
            izq = self.encontrar_camino(raiz.izquierda, destino, camino + ["izquierda"], nombres + [raiz.izquierda.nombre])
            if izq:
                return izq
        if raiz.derecha:
            der = self.encontrar_camino(raiz.derecha, destino, camino + ["derecha"], nombres + [raiz.derecha.nombre])
            if der:
                return der
        return None


if __name__ == "__main__":
    root = ctk.CTk()
    app = JuegoCiberseguridadCTK(root)
    root.mainloop()
