import customtkinter as ctk
from tkinter import messagebox
import random


class Nodo:
    def __init__(self, nombre, retos):
        self.nombre = nombre
        self.retos = retos
        self.izquierda = None
        self.derecha = None

    def obtener_reto(self):
        return random.choice(self.retos)


class JuegoCiberseguridadCTK:
    def __init__(self, root):
        self.root = root
        self.root.title("Aventura Cibern√©tica üß†")
        self.root.geometry("1250x600")

        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("green")

        # Construcci√≥n del √°rbol
        self.raiz = self.construir_arbol()
        self.objetivo = "Nodo Central Seguro"
        self.actual = self.raiz
        self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()

        # Seguimiento de progreso (Ajna)
        self.nodos_visitados = []
        self.nodos_correctos = set()
        self.nodos_pendientes = set()
        self.nodos_usadas_en_pistas = set()
        self.contador_respuestas = 0
        self.mapa_visible = False
        self.botones_mapa = {}

        # --- INTERFAZ ---
        self.main_frame = ctk.CTkFrame(root)
        self.main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # Panel de juego principal
        self.frame_juego = ctk.CTkFrame(self.main_frame)
        self.frame_juego.pack(side="left", fill="both", expand=True, padx=10)

        self.titulo = ctk.CTkLabel(self.frame_juego, text="üåê Aventura Cibern√©tica üåê",
                                   font=("Arial Rounded MT Bold", 24))
        self.titulo.pack(pady=10)

        self.texto_nodo = ctk.CTkLabel(self.frame_juego, text="", font=("Arial", 18, "bold"), wraplength=600)
        self.texto_nodo.pack(pady=10)

        self.texto_reto = ctk.CTkLabel(self.frame_juego, text="", font=("Arial", 15), wraplength=600)
        self.texto_reto.pack(pady=10)

        self.entrada = ctk.CTkEntry(self.frame_juego, width=300, font=("Arial", 14))
        self.entrada.pack(pady=5)
        self.entrada.bind("<Return>", lambda event: self.validar_respuesta())

        self.boton_responder = ctk.CTkButton(self.frame_juego, text="Responder",
                                             command=self.validar_respuesta, width=120, height=35)
        self.boton_responder.pack(pady=5)

        # Botones de movimiento
        self.frame_botones = ctk.CTkFrame(self.frame_juego)
        self.frame_botones.pack(pady=15)

        self.boton_izquierda = ctk.CTkButton(self.frame_botones, text="‚Üê Izquierda", width=120,
                                             command=lambda: self.mover("izquierda"), state="disabled")
        self.boton_izquierda.grid(row=0, column=0, padx=10)

        self.boton_derecha = ctk.CTkButton(self.frame_botones, text="Derecha ‚Üí", width=120,
                                           command=lambda: self.mover("derecha"), state="disabled")
        self.boton_derecha.grid(row=0, column=1, padx=10)

        self.boton_salir = ctk.CTkButton(self.frame_juego, text="Salir", fg_color="#ff4c4c",
                                         hover_color="#d12d2d", command=root.quit, width=100, height=30)
        self.boton_salir.pack(pady=10)

        # --- PANEL DERECHO ---
        self.frame_info = ctk.CTkFrame(self.main_frame)
        self.frame_info.pack(side="right", fill="both", padx=10, pady=10)

        # Lista de nodos visitados 
        self.titulo_visitados = ctk.CTkLabel(self.frame_info, text="üó∫Ô∏è Nodos visitados",
                                            font=("Arial Rounded MT Bold", 16))
        self.titulo_visitados.pack(pady=10)

        self.frame_nodos = ctk.CTkScrollableFrame(self.frame_info, width=250, height=250)
        self.frame_nodos.pack(pady=5)

        # Pistas inteligentes (Ajna)
        self.label_pista = ctk.CTkLabel(self.frame_info, text="A√∫n no hay pistas disponibles.",
                                        font=("Arial", 13), wraplength=250, justify="left")
        self.label_pista.pack(pady=10)

        # Mapa (inicialmente oculto) (Vala)
        self.frame_mapa = ctk.CTkFrame(self.frame_info)
        self.mapa_frame = ctk.CTkFrame(self.frame_mapa, width=600, height=400)
        self.mapa_frame.pack_propagate(False)
        self.mapa_frame.pack(fill="both", expand=True, padx=10, pady=10)
        self.nodos_visitados.append(self.actual.nombre)
        self.actualizar_lista_nodos()
        self.mostrar_nodo()


    # --- Construcci√≥n del √°rbol --- (Jose)
    def construir_arbol(self):
        self.nodo_central = Nodo("Nodo Central Seguro", [
            ("Has restaurado la red. ¬°Felicitaciones, has ganado!", "")
        ])

        ids = Nodo("Sistema IDS", [("¬øQu√© hace un sistema IDS?\n"
                                    "a) Detecta intrusiones\n"
                                    "b) Almacena correos\n"
                                    "c) Bloquea puertos USB", "a")])
        proxy = Nodo("Proxy Seguro", [("¬øPara qu√© sirve un proxy?\n"
                                    "a) Ocultar IPs y filtrar tr√°fico\n"
                                    "b) Acelerar WiFi\n"
                                    "c) Guardar contrase√±as", "a")])
        servidor_web = Nodo("Servidor Web", [("¬øQu√© ataque explota formularios sin validaci√≥n?\n"
                                            "a) Inyecci√≥n SQL\n"
                                            "b) DDoS\n"
                                            "c) Ingenier√≠a social", "a")])
        base_datos = Nodo("Base de Datos", [("¬øQu√© protege mejor una base de datos?\n"
                                            "a) Cifrar datos\n"
                                            "b) Acceso libre\n"
                                            "c) Contrase√±as simples", "a")])
        firewall = Nodo("Firewall Perimetral", [("¬øCu√°l es la funci√≥n principal de un firewall?\n"
                                                "a) Filtrar tr√°fico\n"
                                                "b) Acelerar internet\n"
                                                "c) Guardar contrase√±as", "a")])
        correo = Nodo("Servidor de Correo", [("Identifica el phishing:\n"
                                            "a) Correo con enlace sospechoso\n"
                                            "b) DDoS\n"
                                            "c) Virus f√≠sico", "a")])
        raiz = Nodo("Servidor Principal", [("Detecta la vulnerabilidad m√°s grave:\n"
                                            "a) Contrase√±a d√©bil\n"
                                            "b) Sistema actualizado\n"
                                            "c) Antivirus activo", "a")])
        logs_servidor = Nodo("Logs de Servidor", [
            ("Si ves muchos intentos de contrase√±a fallidos en los registros, ¬øqu√© puede estar pasando?\n"
            "a) Alguien est√° probando muchas contrase√±as\n"
            "b) El computador est√° apagado\n"
            "c) Hay un problema con el teclado", "a")
        ])
        gestion_parches = Nodo("Gesti√≥n de Parches", [
            ("Cuando un programa tiene un error de seguridad, el fabricante env√≠a una 'actualizaci√≥n'. ¬øQu√© debes hacer?\n"
            "a) Instalar la actualizaci√≥n de inmediato\n"
            "b) Esperar un a√±o para instalarla\n"
            "c) Borrar el programa", "a")
        ])

        configuracion = random.choice([1, 2, 3])

        if configuracion == 1:
            raiz.izquierda = firewall
            raiz.derecha = correo
            firewall.izquierda = ids
            firewall.derecha = proxy
            proxy.derecha = self.nodo_central
            correo.izquierda = servidor_web
            correo.derecha = base_datos
            ids.izquierda = logs_servidor
            ids.derecha = gestion_parches

        elif configuracion == 2:
            raiz.izquierda = proxy
            raiz.derecha = firewall
            proxy.izquierda = ids
            proxy.derecha = servidor_web
            servidor_web.derecha = self.nodo_central
            firewall.izquierda = base_datos
            firewall.derecha = correo
            ids.izquierda = logs_servidor
            ids.derecha = gestion_parches

        else:  
            raiz.izquierda = correo
            raiz.derecha = base_datos
            correo.izquierda = firewall
            correo.derecha = ids
            ids.izquierda = gestion_parches
            ids.derecha = proxy
            base_datos.derecha = servidor_web
            proxy.derecha = self.nodo_central  
            firewall.izquierda = logs_servidor

        # Asegurar que el nodo central no tenga hijos
        self.nodo_central.izquierda = None
        self.nodo_central.derecha = None

        print(f"üå≤ Configuraci√≥n seleccionada: {configuracion}")
        return raiz



    # --- Mostrar nodo actual ---
    def mostrar_nodo(self):
        self.texto_nodo.configure(text=f"üîπ Est√°s en: {self.actual.nombre}")
        self.texto_reto.configure(text=self.pregunta_actual)
        self.entrada.delete(0, 'end')
        self.entrada.focus()
        self.boton_izquierda.configure(state="disabled")
        self.boton_derecha.configure(state="disabled")

        if self.actual.nombre not in self.nodos_visitados:
            self.nodos_visitados.append(self.actual.nombre)
            self.actualizar_lista_nodos()

        if self.mapa_visible:
            self.actualizar_mapa()


    # --- Lista de nodos visitados --- (Ajna)
    def actualizar_lista_nodos(self):
        for widget in self.frame_nodos.winfo_children():
            widget.destroy()

        for nodo in self.nodos_visitados:
            boton = ctk.CTkButton(self.frame_nodos, text=f"‚úÖ {nodo}", width=220, height=28,
                                  command=lambda n=nodo: self.ir_a_nodo(n))
            boton.pack(pady=3)


    def ir_a_nodo(self, nombre_nodo):
        nodo = self.buscar_nodo_por_nombre(self.raiz, nombre_nodo)
        if nodo:
            self.actual = nodo
            self.pregunta_actual, self.respuesta_correcta = nodo.obtener_reto()
            messagebox.showinfo("üß≠ Navegaci√≥n", f"Has vuelto al nodo: {nombre_nodo}")
            self.mostrar_nodo()
        else:
            messagebox.showwarning("Error", "No se pudo encontrar el nodo en el √°rbol.")


    def buscar_nodo_por_nombre(self, raiz, nombre):
        if raiz is None:
            return None
        if raiz.nombre == nombre:
            return raiz
        return self.buscar_nodo_por_nombre(raiz.izquierda, nombre) or \
               self.buscar_nodo_por_nombre(raiz.derecha, nombre)


    # --- Validaci√≥n de respuesta --- (Vala)
    def validar_respuesta(self):
        respuesta = self.entrada.get().strip().lower()

        if self.actual.nombre == self.objetivo:
            messagebox.showinfo("Victoria", self.pregunta_actual)
            self.root.quit()
            return

        if respuesta != self.respuesta_correcta:
            messagebox.showwarning("Incorrecto", "‚ùå Respuesta incorrecta. Te lleg√≥ un nuevo desaf√≠o...")
            self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()
            self.mostrar_nodo()
        else:
            messagebox.showinfo("Correcto", "‚úÖ Respuesta correcta. Puedes avanzar.")
            self.boton_izquierda.configure(state="normal")
            self.boton_derecha.configure(state="normal")

            if self.actual.nombre not in self.nodos_correctos:
                self.nodos_correctos.add(self.actual.nombre)
                self.contador_respuestas += 1

            if self.contador_respuestas % 2 == 0:
                self.mostrar_pista()


    # --- Movimiento entre nodos ---
    def mover(self, direccion):
        if direccion == "izquierda" and self.actual.izquierda:
            self.actual = self.actual.izquierda
        elif direccion == "derecha" and self.actual.derecha:
            self.actual = self.actual.derecha
        else:
            messagebox.showinfo("Movimiento inv√°lido", "No hay nodo en esa direcci√≥n.")
            return

        self.pregunta_actual, self.respuesta_correcta = self.actual.obtener_reto()
        self.mostrar_nodo()


    # --- Pistas y mapa --- (Ajna)
    def mostrar_pista(self):
        if not self.mapa_visible:
            self.frame_mapa.pack(fill="both", expand=True, padx=10, pady=10)
            self.mapa_visible = True
            self.actualizar_mapa()
            self.root.after(1800, self.ocultar_mapa)

        camino_actual = self.encontrar_camino(self.raiz, self.actual.nombre)
        camino_objetivo = self.encontrar_camino(self.raiz, self.objetivo)

        if not camino_actual or not camino_objetivo:
            self.label_pista.configure(text="‚ùì No se pudo calcular la pista.")
            return

        direcciones_actual, nombres_actual = camino_actual
        direcciones_objetivo, nombres_objetivo = camino_objetivo

        # Si ya estamos en el nodo final
        if self.actual.nombre == self.objetivo:
            self.label_pista.configure(text="üèÅ ¬°Ya est√°s en el Nodo Central Seguro!")
            return

        # Caso 1: si el nodo actual aparece dentro del camino del objetivo
        if self.actual.nombre in nombres_objetivo:
            idx = nombres_objetivo.index(self.actual.nombre)
            if idx < len(direcciones_objetivo):
                siguiente_dir = direcciones_objetivo[idx]
                siguiente_nodo = nombres_objetivo[idx + 1]
                self.label_pista.configure(
                    text=f"üí° Desde aqu√≠, el objetivo est√° hacia la {siguiente_dir}"
                )
            else:
                self.label_pista.configure(text="ü§î Ya casi llegas al nodo final.")
        else:
            # Caso 2: si el nodo actual no est√° en el camino correcto
            self.label_pista.configure(
                text="Est√°s en una rama diferente"
            )

    #(Vala)
    def ocultar_mapa(self): 
        if self.mapa_visible:
            self.frame_mapa.pack_forget()
            self.mapa_visible = False
            self.label_pista.configure(text="üïµÔ∏è‚Äç‚ôÇÔ∏è El mapa se ha ocultado. ¬°Sigue explorando!")


    def actualizar_mapa(self):
        for widget in self.mapa_frame.winfo_children():
            widget.destroy()
        
        self.dibujar_arbol_recursivo(self.raiz, 0, 0, 8)  #8 es el ancho total inicial

    def dibujar_arbol_recursivo(self, nodo, nivel, col_izquierda, ancho_total):
        if not nodo:
            return
        
        columna = col_izquierda + ancho_total // 2
        
        self.crear_label(nodo, nivel, columna)
        
        if nodo.izquierda or nodo.derecha:
            nuevo_ancho = ancho_total // 2
            if nodo.izquierda:
                self.dibujar_arbol_recursivo(nodo.izquierda, nivel + 1, col_izquierda, nuevo_ancho)
            if nodo.derecha:
                self.dibujar_arbol_recursivo(nodo.derecha, nivel + 1, col_izquierda + nuevo_ancho, nuevo_ancho)

    def crear_label(self, nodo, fila, col):
        if not nodo:
            return
        color = "#2ecc71" if nodo.nombre in self.nodos_visitados else "#555555"
        lbl = ctk.CTkLabel(
            self.mapa_frame,
            text=nodo.nombre,
            font=("Arial", 9, "bold"),
            fg_color=color,
            corner_radius=10,
            width=35,       
            height=20,       
            wraplength=90,   
            justify="center" 
        )
        lbl.grid(row=fila, column=col, padx=4, pady=4)


    def encontrar_camino(self, raiz, destino, camino=None, nombres=None):
        if raiz is None:
            return None
        if camino is None:
            camino = []
        if nombres is None:
            nombres = [raiz.nombre]
        if raiz.nombre == destino:
            return camino, nombres
        if raiz.izquierda:
            izq = self.encontrar_camino(raiz.izquierda, destino, camino + ["izquierda"], nombres + [raiz.izquierda.nombre])
            if izq:
                return izq
        if raiz.derecha:
            der = self.encontrar_camino(raiz.derecha, destino, camino + ["derecha"], nombres + [raiz.derecha.nombre])
            if der:
                return der
        return None


if __name__ == "__main__":
    root = ctk.CTk()
    app = JuegoCiberseguridadCTK(root)
    root.mainloop()
